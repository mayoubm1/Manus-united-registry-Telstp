import { createElement, useMemo, useContext, useRef, useEffect, useState } from 'react';
import { ANIMATOR_STATES as STATES, ANIMATOR_ACTIONS as ACTIONS, createAnimatorSystem } from '@arwes/animator';
import { AnimatorContext } from '../internal/AnimatorContext/index.js';
import { AnimatorGeneralContext } from '../internal/AnimatorGeneralContext/index.js';
const setNodeRefValue = (nodeRef, node) => {
    if (typeof nodeRef === 'function') {
        nodeRef(node);
    }
    else if (nodeRef) {
        nodeRef.current = node;
    }
};
const Animator = (props) => {
    const { root, disabled, dismissed, unmountOnExited, unmountOnEntered, unmountOnDisabled, refreshOn, nodeRef, children, ...settings } = props;
    const parentAnimatorInterface = useContext(AnimatorContext);
    const animatorGeneralInterface = useContext(AnimatorGeneralContext);
    const settingsRef = useRef(settings);
    const prevAnimatorRef = useRef(undefined);
    const isMountedRef = useRef(true);
    settingsRef.current = settings;
    const animatorGeneralSettings = animatorGeneralInterface?.getSettings();
    const isRoot = !!root || !parentAnimatorInterface;
    const isDismissed = dismissed !== undefined ? !!dismissed : !!animatorGeneralSettings?.dismissed;
    const isDisabled = disabled !== undefined ? !!disabled : !!animatorGeneralSettings?.disabled;
    const animatorInterface = useMemo(() => {
        if (prevAnimatorRef.current) {
            prevAnimatorRef.current.system.unregister(prevAnimatorRef.current.node);
        }
        if (isDismissed) {
            setNodeRefValue(nodeRef, null);
            return parentAnimatorInterface;
        }
        if (isDisabled) {
            setNodeRefValue(nodeRef, null);
            return undefined;
        }
        const system = isRoot ? createAnimatorSystem() : parentAnimatorInterface.system;
        const getSettings = () => {
            const animatorGeneralSettings = animatorGeneralInterface?.getSettings();
            const duration = {
                ...animatorGeneralSettings?.duration,
                ...settingsRef.current.duration
            };
            return {
                ...animatorGeneralSettings,
                ...settingsRef.current,
                duration
            };
        };
        const node = isRoot
            ? system.register(undefined, { getSettings })
            : system.register(parentAnimatorInterface.node, { getSettings });
        setNodeRefValue(nodeRef, node);
        return Object.freeze({ system, node });
    }, [parentAnimatorInterface, isRoot, isDisabled, isDismissed]);
    prevAnimatorRef.current = animatorInterface;
    const [isEnabledToUnmount, setIsEnabledToUnmount] = useState(() => (unmountOnExited && animatorInterface?.node.state === STATES.exited) ||
        (unmountOnEntered && animatorInterface?.node.state === STATES.entered) ||
        (unmountOnDisabled && isDisabled));
    useEffect(() => {
        return () => {
            isMountedRef.current = false;
            if (prevAnimatorRef.current) {
                prevAnimatorRef.current.system.unregister(prevAnimatorRef.current.node);
            }
        };
    }, []);
    useEffect(() => {
        if (!animatorInterface) {
            return;
        }
        queueMicrotask(() => {
            if (!isMountedRef.current) {
                return;
            }
            animatorInterface.node.send(ACTIONS.setup);
        });
    }, [!!animatorInterface]);
    const isFirstRender1Ref = useRef(true);
    useEffect(() => {
        if (isFirstRender1Ref.current) {
            isFirstRender1Ref.current = false;
            return;
        }
        if (!animatorInterface) {
            return;
        }
        queueMicrotask(() => {
            if (!isMountedRef.current) {
                return;
            }
            animatorInterface.node.send(ACTIONS.update);
        });
    }, [settings.active, settings.manager, settings.merge, settings.combine]);
    useEffect(() => {
        if (animatorInterface) {
            const cancelSubscription = animatorInterface.node.subscribe((node) => {
                setIsEnabledToUnmount((unmountOnExited && node.state === STATES.exited) ||
                    (unmountOnEntered && node.state === STATES.entered));
            });
            return () => cancelSubscription();
        }
        else {
            setIsEnabledToUnmount(unmountOnDisabled);
        }
    }, [animatorInterface, unmountOnExited, unmountOnEntered, unmountOnDisabled]);
    const isFirstRender2Ref = useRef(true);
    useEffect(() => {
        if (isFirstRender2Ref.current) {
            isFirstRender2Ref.current = false;
            return;
        }
        if (animatorInterface) {
            queueMicrotask(() => {
                if (!isMountedRef.current) {
                    return;
                }
                animatorInterface.node.send(ACTIONS.refresh);
            });
        }
    }, refreshOn ?? []);
    return createElement(AnimatorContext.Provider, { value: animatorInterface }, isEnabledToUnmount ? null : children);
};
export { Animator };
