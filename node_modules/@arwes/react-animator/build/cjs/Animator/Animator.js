"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Animator = void 0;
const react_1 = require("react");
const animator_1 = require("@arwes/animator");
const index_js_1 = require("../internal/AnimatorContext/index.js");
const index_js_2 = require("../internal/AnimatorGeneralContext/index.js");
const setNodeRefValue = (nodeRef, node) => {
    if (typeof nodeRef === 'function') {
        nodeRef(node);
    }
    else if (nodeRef) {
        nodeRef.current = node;
    }
};
const Animator = (props) => {
    const { root, disabled, dismissed, unmountOnExited, unmountOnEntered, unmountOnDisabled, refreshOn, nodeRef, children, ...settings } = props;
    const parentAnimatorInterface = (0, react_1.useContext)(index_js_1.AnimatorContext);
    const animatorGeneralInterface = (0, react_1.useContext)(index_js_2.AnimatorGeneralContext);
    const settingsRef = (0, react_1.useRef)(settings);
    const prevAnimatorRef = (0, react_1.useRef)(undefined);
    const isMountedRef = (0, react_1.useRef)(true);
    settingsRef.current = settings;
    const animatorGeneralSettings = animatorGeneralInterface?.getSettings();
    const isRoot = !!root || !parentAnimatorInterface;
    const isDismissed = dismissed !== undefined ? !!dismissed : !!animatorGeneralSettings?.dismissed;
    const isDisabled = disabled !== undefined ? !!disabled : !!animatorGeneralSettings?.disabled;
    const animatorInterface = (0, react_1.useMemo)(() => {
        if (prevAnimatorRef.current) {
            prevAnimatorRef.current.system.unregister(prevAnimatorRef.current.node);
        }
        if (isDismissed) {
            setNodeRefValue(nodeRef, null);
            return parentAnimatorInterface;
        }
        if (isDisabled) {
            setNodeRefValue(nodeRef, null);
            return undefined;
        }
        const system = isRoot ? (0, animator_1.createAnimatorSystem)() : parentAnimatorInterface.system;
        const getSettings = () => {
            const animatorGeneralSettings = animatorGeneralInterface?.getSettings();
            const duration = {
                ...animatorGeneralSettings?.duration,
                ...settingsRef.current.duration
            };
            return {
                ...animatorGeneralSettings,
                ...settingsRef.current,
                duration
            };
        };
        const node = isRoot
            ? system.register(undefined, { getSettings })
            : system.register(parentAnimatorInterface.node, { getSettings });
        setNodeRefValue(nodeRef, node);
        return Object.freeze({ system, node });
    }, [parentAnimatorInterface, isRoot, isDisabled, isDismissed]);
    prevAnimatorRef.current = animatorInterface;
    const [isEnabledToUnmount, setIsEnabledToUnmount] = (0, react_1.useState)(() => (unmountOnExited && animatorInterface?.node.state === animator_1.ANIMATOR_STATES.exited) ||
        (unmountOnEntered && animatorInterface?.node.state === animator_1.ANIMATOR_STATES.entered) ||
        (unmountOnDisabled && isDisabled));
    (0, react_1.useEffect)(() => {
        return () => {
            isMountedRef.current = false;
            if (prevAnimatorRef.current) {
                prevAnimatorRef.current.system.unregister(prevAnimatorRef.current.node);
            }
        };
    }, []);
    (0, react_1.useEffect)(() => {
        if (!animatorInterface) {
            return;
        }
        queueMicrotask(() => {
            if (!isMountedRef.current) {
                return;
            }
            animatorInterface.node.send(animator_1.ANIMATOR_ACTIONS.setup);
        });
    }, [!!animatorInterface]);
    const isFirstRender1Ref = (0, react_1.useRef)(true);
    (0, react_1.useEffect)(() => {
        if (isFirstRender1Ref.current) {
            isFirstRender1Ref.current = false;
            return;
        }
        if (!animatorInterface) {
            return;
        }
        queueMicrotask(() => {
            if (!isMountedRef.current) {
                return;
            }
            animatorInterface.node.send(animator_1.ANIMATOR_ACTIONS.update);
        });
    }, [settings.active, settings.manager, settings.merge, settings.combine]);
    (0, react_1.useEffect)(() => {
        if (animatorInterface) {
            const cancelSubscription = animatorInterface.node.subscribe((node) => {
                setIsEnabledToUnmount((unmountOnExited && node.state === animator_1.ANIMATOR_STATES.exited) ||
                    (unmountOnEntered && node.state === animator_1.ANIMATOR_STATES.entered));
            });
            return () => cancelSubscription();
        }
        else {
            setIsEnabledToUnmount(unmountOnDisabled);
        }
    }, [animatorInterface, unmountOnExited, unmountOnEntered, unmountOnDisabled]);
    const isFirstRender2Ref = (0, react_1.useRef)(true);
    (0, react_1.useEffect)(() => {
        if (isFirstRender2Ref.current) {
            isFirstRender2Ref.current = false;
            return;
        }
        if (animatorInterface) {
            queueMicrotask(() => {
                if (!isMountedRef.current) {
                    return;
                }
                animatorInterface.node.send(animator_1.ANIMATOR_ACTIONS.refresh);
            });
        }
    }, refreshOn ?? []);
    return (0, react_1.createElement)(index_js_1.AnimatorContext.Provider, { value: animatorInterface }, isEnabledToUnmount ? null : children);
};
exports.Animator = Animator;
