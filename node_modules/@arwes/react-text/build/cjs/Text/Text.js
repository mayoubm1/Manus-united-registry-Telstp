"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Text = void 0;
const react_1 = require("react");
const tools_1 = require("@arwes/tools");
const react_tools_1 = require("@arwes/react-tools");
const react_animator_1 = require("@arwes/react-animator");
const text_1 = require("@arwes/text");
const Text = (0, react_tools_1.memo)((props) => {
    const { as: asProvided = 'p', className, contentClassName, contentStyle, children, manager, easing, fixed, blink, blinkDuration, characters, hideOnEntered, hideOnExited = true, elementRef: elementRefProvided, ...otherProps } = props;
    const as = (0, react_1.useMemo)(() => asProvided, []);
    const [childrenText, setChildrenText] = (0, react_1.useState)('');
    const elementRef = (0, react_1.useRef)(null);
    const contentElementRef = (0, react_1.useRef)(null);
    const transitionControl = (0, react_1.useRef)(null);
    const animator = (0, react_animator_1.useAnimator)();
    (0, react_1.useEffect)(() => {
        setChildrenText(contentElementRef.current?.textContent ?? '');
    }, [children]);
    (0, react_1.useEffect)(() => {
        const rootElement = elementRef.current;
        const contentElement = contentElementRef.current;
        if (!animator || !childrenText.length || !rootElement || !contentElement) {
            return;
        }
        if (!fixed) {
            const { settings } = animator.node;
            const durationEnter = (0, text_1.getAnimationTextDuration)({
                length: childrenText.length,
                maxDuration: settings.duration.enter
            });
            const durationExit = (0, text_1.getAnimationTextDuration)({
                length: childrenText.length,
                maxDuration: settings.duration.exit
            });
            animator.node.control.setSettings({
                duration: { enter: durationEnter, exit: durationExit }
            });
        }
        const transition = (duration, isEntering) => {
            const baseOptions = {
                rootElement,
                contentElement,
                duration,
                isEntering,
                easing,
                hideOnExited,
                hideOnEntered
            };
            transitionControl.current?.cancel();
            if (manager === 'decipher') {
                transitionControl.current = (0, text_1.animateTextDecipher)({ ...baseOptions, characters });
            }
            else {
                transitionControl.current = (0, text_1.animateTextSequence)({ ...baseOptions, blink, blinkDuration });
            }
        };
        const unsubscribe = animator.node.subscribe((node) => {
            switch (node.state) {
                case 'entering': {
                    transition(node.settings.duration.enter, true);
                    break;
                }
                case 'entered': {
                    if (!transitionControl.current) {
                        transition(node.settings.duration.enter, true);
                    }
                    break;
                }
                case 'exiting': {
                    transition(node.settings.duration.exit, false);
                    break;
                }
            }
        });
        return () => {
            unsubscribe();
            transitionControl.current?.cancel();
            transitionControl.current = null;
        };
    }, [animator, childrenText]);
    return (0, react_1.createElement)(as, {
        ...otherProps,
        className: (0, tools_1.cx)('arwes-text-text', className),
        style: {
            position: 'relative',
            ...otherProps.style
        },
        ref: (0, react_tools_1.mergeRefs)(elementRefProvided, elementRef)
    }, (0, react_1.createElement)('span', {
        ref: contentElementRef,
        className: (0, tools_1.cx)('arwes-text-text__content', contentClassName),
        style: {
            position: 'relative',
            visibility: animator
                ? (animator.node.state === 'exited' && hideOnExited) ||
                    (animator.node.state === 'entered' && hideOnEntered)
                    ? 'hidden'
                    : ''
                : undefined,
            ...contentStyle
        }
    }, children));
});
exports.Text = Text;
