import { createElement, useMemo, useState, useRef, useEffect } from 'react';
import { cx } from '@arwes/tools';
import { memo, mergeRefs } from '@arwes/react-tools';
import { useAnimator } from '@arwes/react-animator';
import { getAnimationTextDuration, animateTextSequence, animateTextDecipher } from '@arwes/text';
const Text = memo((props) => {
    const { as: asProvided = 'p', className, contentClassName, contentStyle, children, manager, easing, fixed, blink, blinkDuration, characters, hideOnEntered, hideOnExited = true, elementRef: elementRefProvided, ...otherProps } = props;
    const as = useMemo(() => asProvided, []);
    const [childrenText, setChildrenText] = useState('');
    const elementRef = useRef(null);
    const contentElementRef = useRef(null);
    const transitionControl = useRef(null);
    const animator = useAnimator();
    useEffect(() => {
        setChildrenText(contentElementRef.current?.textContent ?? '');
    }, [children]);
    useEffect(() => {
        const rootElement = elementRef.current;
        const contentElement = contentElementRef.current;
        if (!animator || !childrenText.length || !rootElement || !contentElement) {
            return;
        }
        if (!fixed) {
            const { settings } = animator.node;
            const durationEnter = getAnimationTextDuration({
                length: childrenText.length,
                maxDuration: settings.duration.enter
            });
            const durationExit = getAnimationTextDuration({
                length: childrenText.length,
                maxDuration: settings.duration.exit
            });
            animator.node.control.setSettings({
                duration: { enter: durationEnter, exit: durationExit }
            });
        }
        const transition = (duration, isEntering) => {
            const baseOptions = {
                rootElement,
                contentElement,
                duration,
                isEntering,
                easing,
                hideOnExited,
                hideOnEntered
            };
            transitionControl.current?.cancel();
            if (manager === 'decipher') {
                transitionControl.current = animateTextDecipher({ ...baseOptions, characters });
            }
            else {
                transitionControl.current = animateTextSequence({ ...baseOptions, blink, blinkDuration });
            }
        };
        const unsubscribe = animator.node.subscribe((node) => {
            switch (node.state) {
                case 'entering': {
                    transition(node.settings.duration.enter, true);
                    break;
                }
                case 'entered': {
                    if (!transitionControl.current) {
                        transition(node.settings.duration.enter, true);
                    }
                    break;
                }
                case 'exiting': {
                    transition(node.settings.duration.exit, false);
                    break;
                }
            }
        });
        return () => {
            unsubscribe();
            transitionControl.current?.cancel();
            transitionControl.current = null;
        };
    }, [animator, childrenText]);
    return createElement(as, {
        ...otherProps,
        className: cx('arwes-text-text', className),
        style: {
            position: 'relative',
            ...otherProps.style
        },
        ref: mergeRefs(elementRefProvided, elementRef)
    }, createElement('span', {
        ref: contentElementRef,
        className: cx('arwes-text-text__content', contentClassName),
        style: {
            position: 'relative',
            visibility: animator
                ? (animator.node.state === 'exited' && hideOnExited) ||
                    (animator.node.state === 'entered' && hideOnEntered)
                    ? 'hidden'
                    : ''
                : undefined,
            ...contentStyle
        }
    }, children));
});
export { Text };
